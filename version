#!/usr/bin/env ruby
require 'thor'
require 'open3'
require 'git_wrapper'

GitWrapper.logger.level = Logger::ERROR

class VersionInfo
  attr_accessor :major, :minor, :build

  def initialize(version)
    parts = version.split '.'
    @major = parts[0].to_i
    @minor = parts[1].to_i
    @build = parts[2].to_i
  end

  def increment(part)
    send("#{part}=", send("#{part}") + 1)
    self
  end

  def reset(part)
    send("#{part}=", 0)
    self
  end

  def to_s
    "#{major}.#{minor}.#{build}"
  end

  def <=>(other)
    return major <=> other.major if (major <=> other.major) != 0
    return minor <=> other.minor if (minor <=> other.minor) != 0
    build <=> other.build
  end

end

class Version < Thor

  desc 'last', 'Get last version'

  def last
    return unless valid_repo?
    puts last_version
  end

  desc 'build', 'Increment tag and branch build version (0.0.1)'

  def build
    return unless valid_repo?
    release last_version.increment(:build)
  end

  desc 'minor', 'Increment tag and branch minor version (0.1.0)'

  def minor
    return unless valid_repo?
    release last_version.increment(:minor).reset(:build)
  end

  desc 'major', 'Increment tag and branch major version (1.0.0)'

  def major
    return unless valid_repo?
    release last_version.increment(:major).reset(:minor).reset(:build)
  end

  desc 'release', 'Generate tag and branch for specific version (Branch: 1.2.3, Tag: v1.2.3)'

  def release(version=nil)
    return unless valid_repo?
    return if !version && !valid_version?

    puts "Generating version #{version}"

    puts '- Creating tag'
    repo.tag "v#{version || repo.current_branch}"

    puts '- Pushing tag'
    repo.push 'origin', "v#{version || repo.current_branch}"

    if version
      puts '- Creating branch'
      repo.branch version
    end

    puts '- Pushing branch'
    repo.push 'origin', version || repo.current_branch
  end

  desc 'remove', 'Remove specific version from git repo'

  def remove(version)
    return unless valid_repo?

    puts "Removing version #{version}"

    puts '- Removing local tag'
    repo.remove_tag "v#{version}"

    puts '- Removing remote tag'
    repo.push 'origin', ":v#{version}"

    puts '- Removing local branch'
    repo.remove_branch version

    puts '- Removing remote branch'
    repo.push 'origin', ":#{version}"
  end

  desc 'fix', 'Increment build from current branch'

  def fix
    return if !valid_repo? || !valid_version?

    version = VersionInfo.new(repo.current_branch).increment(:build)

    puts "Creating branch #{version}"
    repo.branch version

    puts 'Checkouting'
    repo.checkout version
  end

  desc 'upgrade', 'Checkout last version'

  def upgrade
    change :last
  end

  desc 'change', 'Checkout specific version'

  def change(version)
    return unless valid_repo?

    puts 'Fetching from remote'
    repo.fetch 'origin'
    version = version == :last ? last_version.to_s : version

    puts "Changing to #{version}"
    repo.checkout version
  end

  desc 'gem', 'Publish private gem version'

  def gem
    return unless valid_repo? && valid_gem? && valid_pending_changes?

    gemspec = Gem::Specification.load(gem_file)

    puts "Generating version #{gemspec.version}"

    puts '- Pushing changes'
    repo.push

    puts '- Creating tag'
    repo.tag "v#{gemspec.version}"

    puts '- Pushing tag'
    repo.push 'origin', "v#{gemspec.version}"

    puts '- Packaging gem'
    Open3.popen3 'rake build' do |i, o, e, t|
      puts o.readlines
      puts e.readlines
    end

    puts '- Sending to geminabox'
    Open3.popen3 "gem inabox pkg/#{gemspec.name}-#{gemspec.version}.gem" do |i, o, e, t|
      puts o.readlines
      puts e.readlines
    end
  end

  private

  def repo
    GitWrapper::Repository.new Dir.pwd
  end

  def valid_repo?
    puts "Invalid application path [#{repo.location}]" unless repo.initialized?
    repo.initialized?
  end

  def valid_gem?
    unless gem_file
      puts "Is not gem path [#{repo.location}]"
      return false
    end
    true
  end

  def gem_file
    Dir.glob("#{repo.location}/*.gemspec").first
  end

  def valid_pending_changes?
    if repo.status.any?
      puts "There are pending changes (#{repo.status.count})"
      false
    else
      true
    end
  end

  def valid_version?
    unless repo.current_branch.match /[0-9]+\.[0-9]+\.[0-9]+/
      puts "Is not branch version [#{repo.current_branch}]"
      return false
    end
    true
  end

  def last_version
    versions = repo.tags.
        select { |t| t.match /v[0-9]+\.[0-9]+\.[0-9]+/ }.
        map { |t| VersionInfo.new(t[1..-1]) }.
        sort
    versions.last || VersionInfo.new('v0.0.0')
  end

end

Version.start